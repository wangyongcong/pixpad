#include <cstdio>
#include <cassert>
#include "vector.h"
#include "matrix.h"

using namespace wyc;

namespace test
{
	//-----------------------------------------------------------------------------------
	// basic test
	//-----------------------------------------------------------------------------------

	template<class T>
	void test_matrix22()
	{
		typedef xmatrix<T, 2, 2> matrix_t;
		typedef xvector<T, 2> vector_t;
		typedef T scalar_t;
		matrix_t m1, m2, m3;
		m1.identity();
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1
			);
		m2 = m1;
		assert(m1 == m2);
		m2 = {
			0, 0,
			0, 0,
		};
		assert(m1 != m2);
		assert(m1 >= m2);
		vector_t v1 = m1.row(0);
		assert(v1.x == 1 && v1.y == 0);
		v1 = m1.col(1);
		assert(v1.x == 0 && v1.y == 1);
		m1 += 1.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 1 &&
			m1[1][0] == 1 && m1[1][1] == 2
			);
		m1 -= 1.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1
			);
		m1 *= 2.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 2
			);
		m1 /= 2.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1
			);
		m2.set_row(0, { 1, 2 });
		m2.set_col(1, { 2, 3 });
		assert(
			m2[0][0] == 1 && m2[0][1] == 2 &&
			m2[1][0] == 0 && m2[1][1] == 3
			);
		m1 += m2;
		assert(
			m1[0][0] == 2 && m1[0][1] == 2 &&
			m1[1][0] == 0 && m1[1][1] == 4
			);
		m1 -= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1
			);
		m1 *= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 2 &&
			m1[1][0] == 0 && m1[1][1] == 3
			);
		m1.identity();
		m3.add(m1, m2);
		assert(
			m3[0][0] == 2 && m3[0][1] == 2 &&
			m3[1][0] == 0 && m3[1][1] == 4
			);
		m3.sub(m1, m2);
		assert(
			m3[0][0] == 0 && m3[0][1] == -2 &&
			m3[1][0] == 0 && m3[1][1] == -2
			);
		m3.mul(m1, m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 2 &&
			m3[1][0] == 0 && m3[1][1] == 3
			);
		m3.transpose_of(m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 0 &&
			m3[1][0] == 2 && m3[1][1] == 3
			);
		m3.transpose();
		assert(m3 == m2);
		m2.identity();
		m2[1][0] = 1;
		m2[1][1] = 2;
		scalar_t det = m2.determinant();
		if (det != 0) {
			m3.inverse_of(m2);
			m3 *= m2;
			assert(m1 == m3);
		}
	}

	template<class T>
	void test_matrix33()
	{
		typedef xmatrix<T, 3, 3> matrix_t;
		typedef xvector<T, 3> vector_t;
		typedef T scalar_t;
		matrix_t m1, m2, m3;
		m1.identity();
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1);
		m2 = m1;
		assert(m1 == m2);
		m2 = {
			0, 0, 0,
			0, 0, 0,
			0, 0, 0,
		};
		assert(m1 != m2);
		assert(m1 >= m2);
		vector_t v1 = m1.row(0);
		assert(v1.x == 1 && v1.y == 0 && v1.z == 0);
		v1 = m1.col(1);
		assert(v1.x == 0 && v1.y == 1 && v1.z == 0);
		m1 += 1.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 1 && m1[0][2] == 1 &&
			m1[1][0] == 1 && m1[1][1] == 2 && m1[1][2] == 1 &&
			m1[2][0] == 1 && m1[2][1] == 1 && m1[2][2] == 2);
		m1 -= 1.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1);
		m1 *= 2.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 0 && m1[0][2] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 2 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 2);
		m1 /= 2.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1);
		m2.set_row(0, { 1, 2, 3 });
		m2.set_col(1, { 2, 3, 4 });
		assert(
			m2[0][0] == 1 && m2[0][1] == 2 && m2[0][2] == 3 &&
			m2[1][0] == 0 && m2[1][1] == 3 && m2[1][2] == 0 &&
			m2[2][0] == 0 && m2[2][1] == 4 && m2[2][2] == 0);
		m1 += m2;
		assert(
			m1[0][0] == 2 && m1[0][1] == 2 && m1[0][2] == 3 &&
			m1[1][0] == 0 && m1[1][1] == 4 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 4 && m1[2][2] == 1);
		m1 -= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1);
		m1 *= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 2 && m1[0][2] == 3 &&
			m1[1][0] == 0 && m1[1][1] == 3 && m1[1][2] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 4 && m1[2][2] == 0);
		m1.identity();
		m3.add(m1, m2);
		assert(
			m3[0][0] == 2 && m3[0][1] == 2 && m3[0][2] == 3 &&
			m3[1][0] == 0 && m3[1][1] == 4 && m3[1][2] == 0 &&
			m3[2][0] == 0 && m3[2][1] == 4 && m3[2][2] == 1);
		m3.sub(m1, m2);
		assert(
			m3[0][0] == 0 && m3[0][1] == -2 && m3[0][2] == -3 &&
			m3[1][0] == 0 && m3[1][1] == -2 && m3[1][2] == 0 &&
			m3[2][0] == 0 && m3[2][1] == -4 && m3[2][2] == 1);
		m3.mul(m1, m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 2 && m3[0][2] == 3 &&
			m3[1][0] == 0 && m3[1][1] == 3 && m3[1][2] == 0 &&
			m3[2][0] == 0 && m3[2][1] == 4 && m3[2][2] == 0);
		m3.transpose_of(m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 0 && m3[0][2] == 0 &&
			m3[1][0] == 2 && m3[1][1] == 3 && m3[1][2] == 4 &&
			m3[2][0] == 3 && m3[2][1] == 0 && m3[2][2] == 0);
		m3.transpose();
		assert(m3 == m2);
		m2.identity();
		m2[2][0] = 1;
		m2[2][1] = 2;
		scalar_t det = m2.determinant();
		if (det != 0) {
			m3.inverse_of(m2);
			m3 *= m2;
			assert(m1 == m3);
		}
	}

	template<class T>
	void test_matrix44()
	{
		typedef xmatrix<T, 4, 4> matrix_t;
		typedef xvector<T, 4> vector_t;
		typedef T scalar_t;
		matrix_t m1, m2, m3;
		m1.identity();
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 && m1[0][3] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 0 && m1[3][2] == 0 && m1[3][3] == 1
			);
		m2 = m1;
		assert(m1 == m2);
		m2 = {
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
		};
		assert(m1 != m2);
		assert(m1 >= m2);
		vector_t v1 = m1.row(0);
		assert(v1.x == 1 && v1.y == 0 && v1.z == 0 && v1.w == 0);
		v1 = m1.col(1);
		assert(v1.x == 0 && v1.y == 1 && v1.z == 0 && v1.w == 0);
		m1 += 1.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 1 && m1[0][2] == 1 && m1[0][3] == 1 &&
			m1[1][0] == 1 && m1[1][1] == 2 && m1[1][2] == 1 && m1[1][3] == 1 &&
			m1[2][0] == 1 && m1[2][1] == 1 && m1[2][2] == 2 && m1[2][3] == 1 &&
			m1[3][0] == 1 && m1[3][1] == 1 && m1[3][2] == 1 && m1[3][3] == 2
			);
		m1 -= 1.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 && m1[0][3] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 0 && m1[3][2] == 0 && m1[3][3] == 1
			);
		m1 *= 2.f;
		assert(
			m1[0][0] == 2 && m1[0][1] == 0 && m1[0][2] == 0 && m1[0][3] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 2 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 2 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 0 && m1[3][2] == 0 && m1[3][3] == 2
			);
		m1 /= 2.f;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 && m1[0][3] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 0 && m1[3][2] == 0 && m1[3][3] == 1
			);
		m2.set_row(0, { 1, 2, 3, 4 });
		m2.set_col(1, { 2, 3, 4, 5 });
		assert(
			m2[0][0] == 1 && m2[0][1] == 2 && m2[0][2] == 3 && m2[0][3] == 4 &&
			m2[1][0] == 0 && m2[1][1] == 3 && m2[1][2] == 0 && m2[1][3] == 0 &&
			m2[2][0] == 0 && m2[2][1] == 4 && m2[2][2] == 0 && m2[2][3] == 0 &&
			m2[3][0] == 0 && m2[3][1] == 5 && m2[3][2] == 0 && m2[3][3] == 0
			);
		m1 += m2;
		assert(
			m1[0][0] == 2 && m1[0][1] == 2 && m1[0][2] == 3 && m1[0][3] == 4 &&
			m1[1][0] == 0 && m1[1][1] == 4 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 4 && m1[2][2] == 1 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 5 && m1[3][2] == 0 && m1[3][3] == 1
			);
		m1 -= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 0 && m1[0][2] == 0 && m1[0][3] == 0 &&
			m1[1][0] == 0 && m1[1][1] == 1 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 0 && m1[2][2] == 1 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 0 && m1[3][2] == 0 && m1[3][3] == 1
			);
		m1 *= m2;
		assert(
			m1[0][0] == 1 && m1[0][1] == 2 && m1[0][2] == 3 && m1[0][3] == 4 &&
			m1[1][0] == 0 && m1[1][1] == 3 && m1[1][2] == 0 && m1[1][3] == 0 &&
			m1[2][0] == 0 && m1[2][1] == 4 && m1[2][2] == 0 && m1[2][3] == 0 &&
			m1[3][0] == 0 && m1[3][1] == 5 && m1[3][2] == 0 && m1[3][3] == 0
			);
		m1.identity();
		m3.add(m1, m2);
		assert(
			m3[0][0] == 2 && m3[0][1] == 2 && m3[0][2] == 3 && m3[0][3] == 4 &&
			m3[1][0] == 0 && m3[1][1] == 4 && m3[1][2] == 0 && m3[1][3] == 0 &&
			m3[2][0] == 0 && m3[2][1] == 4 && m3[2][2] == 1 && m3[2][3] == 0 &&
			m3[3][0] == 0 && m3[3][1] == 5 && m3[3][2] == 0 && m3[3][3] == 1
			);
		m3.sub(m1, m2);
		assert(
			m3[0][0] == 0 && m3[0][1] == -2 && m3[0][2] == -3 && m3[0][3] == -4 &&
			m3[1][0] == 0 && m3[1][1] == -2 && m3[1][2] == 0 && m3[1][3] == 0 &&
			m3[2][0] == 0 && m3[2][1] == -4 && m3[2][2] == 1 && m3[2][3] == 0 &&
			m3[3][0] == 0 && m3[3][1] == -5 && m3[3][2] == 0 && m3[3][3] == 1
			);
		m3.mul(m1, m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 2 && m3[0][2] == 3 && m3[0][3] == 4 &&
			m3[1][0] == 0 && m3[1][1] == 3 && m3[1][2] == 0 && m3[1][3] == 0 &&
			m3[2][0] == 0 && m3[2][1] == 4 && m3[2][2] == 0 && m3[2][3] == 0 &&
			m3[3][0] == 0 && m3[3][1] == 5 && m3[3][2] == 0 && m3[3][3] == 0
			);
		m3.transpose_of(m2);
		assert(
			m3[0][0] == 1 && m3[0][1] == 0 && m3[0][2] == 0 && m3[0][3] == 0 &&
			m3[1][0] == 2 && m3[1][1] == 3 && m3[1][2] == 4 && m3[1][3] == 5 &&
			m3[2][0] == 3 && m3[2][1] == 0 && m3[2][2] == 0 && m3[2][3] == 0 &&
			m3[3][0] == 4 && m3[3][1] == 0 && m3[3][2] == 0 && m3[3][3] == 0
			);
		m3.transpose();
		assert(m3 == m2);
		m2.identity();
		m2[3][0] = 1;
		m2[3][1] = 2;
		scalar_t det = m2.determinant();
		if (det != 0) {
			m3.inverse_of(m2);
			m3 *= m2;
			assert(m1 == m3);
		}
	}

	template<class T>
	void test_matrix55()
	{
		typedef xmatrix<T, 5, 5> matrix_t;
		typedef xvector<T, 5> vector_t;
		typedef T scalar_t;
		matrix_t m1, m2, m3;
		m1.identity();
		assert(m1 == matrix_t({
			1, 0, 0, 0, 0,
			0, 1, 0, 0, 0,
			0, 0, 1, 0, 0,
			0, 0, 0, 1, 0,
			0, 0, 0, 0, 1,
		}));
		m2 = m1;
		assert(m1 == m2);
		m2 = {
			0, 0, 0, 0, 0,
			0, 0, 0, 0, 0,
			0, 0, 0, 0, 0,
			0, 0, 0, 0, 0,
			0, 0, 0, 0, 0,
		};
		assert(m1 != m2);
		assert(m1 >= m2);
		vector_t v1 = m1.row(0);
		assert(v1[0] == 1 && v1[1] == 0 && v1[2] == 0 && v1[3] == 0 && v1[4] == 0);
		v1 = m1.col(1);
		assert(v1[0] == 0 && v1[1] == 1 && v1[2] == 0 && v1[3] == 0 && v1[4] == 0);
		m1 += 1.f;
		assert(m1 == matrix_t({
			2, 1, 1, 1, 1,
			1, 2, 1, 1, 1,
			1, 1, 2, 1, 1,
			1, 1, 1, 2, 1,
			1, 1, 1, 1, 2,
		}));
		m1 -= 1.f;
		assert(m1 == matrix_t({
			1, 0, 0, 0, 0,
			0, 1, 0, 0, 0,
			0, 0, 1, 0, 0,
			0, 0, 0, 1, 0,
			0, 0, 0, 0, 1,
		}));
		m1 *= 2.f;
		assert(m1 == matrix_t({
			2, 0, 0, 0, 0,
			0, 2, 0, 0, 0,
			0, 0, 2, 0, 0,
			0, 0, 0, 2, 0,
			0, 0, 0, 0, 2,
		}));
		m1 /= 2.f;
		assert(m1 == matrix_t({
			1, 0, 0, 0, 0,
			0, 1, 0, 0, 0,
			0, 0, 1, 0, 0,
			0, 0, 0, 1, 0,
			0, 0, 0, 0, 1,
		}));
		m2.set_row(0, { 1, 2, 3, 4, 5 });
		m2.set_col(1, { 2, 3, 4, 5, 6 });
		assert(m2 == matrix_t({
			1, 2, 3, 4, 5,
			0, 3, 0, 0, 0,
			0, 4, 0, 0, 0,
			0, 5, 0, 0, 0,
			0, 6, 0, 0, 0,
		}));
		m1 += m2;
		assert(m1 == matrix_t({
			2, 2, 3, 4, 5,
			0, 4, 0, 0, 0,
			0, 4, 1, 0, 0,
			0, 5, 0, 1, 0,
			0, 6, 0, 0, 1,
		}));
		m1 -= m2;
		assert(m1 == matrix_t({
			1, 0, 0, 0, 0,
			0, 1, 0, 0, 0,
			0, 0, 1, 0, 0,
			0, 0, 0, 1, 0,
			0, 0, 0, 0, 1,
		}));
		m1 *= m2;
		assert(m1 == matrix_t({
			1, 2, 3, 4, 5,
			0, 3, 0, 0, 0,
			0, 4, 0, 0, 0,
			0, 5, 0, 0, 0,
			0, 6, 0, 0, 0,
		}));
		m1.identity();
		m3.add(m1, m2);
		assert(m3 == matrix_t({
			2, 2, 3, 4, 5,
			0, 4, 0, 0, 0,
			0, 4, 1, 0, 0,
			0, 5, 0, 1, 0,
			0, 6, 0, 0, 1,
		}));
		m3.sub(m1, m2);
		assert(m3 == matrix_t({
			0, -2, -3, -4, -5,
			0, -2, 0, 0, 0,
			0, -4, 1, 0, 0,
			0, -5, 0, 1, 0,
			0, -6, 0, 0, 1,
		}));
		m3.mul(m1, m2);
		assert(m3 == matrix_t({
			1, 2, 3, 4, 5,
			0, 3, 0, 0, 0,
			0, 4, 0, 0, 0,
			0, 5, 0, 0, 0,
			0, 6, 0, 0, 0,
		}));
		m3.transpose_of(m2);
		assert(m3 == matrix_t({
			1, 0, 0, 0, 0,
			2, 3, 4, 5, 6,
			3, 0, 0, 0, 0,
			4, 0, 0, 0, 0,
			5, 0, 0, 0, 0,
		}));
		m3.transpose();
		assert(m3 == m2);
		m2.identity();
		m2[4][0] = 1;
		m2[4][1] = 2;
		scalar_t det = m2.determinant();
		if (det != 0) {
			m3.inverse_of(m2);
			m3 *= m2;
			assert(m1 == m3);
		}
	}

	void test_matrix()
	{
		printf("testing matrix22...");
		test_matrix22<float>();
		printf("Ok\n");
		printf("testing matrix33...");
		test_matrix33<float>();
		printf("Ok\n");
		printf("testing matrix44...");
		test_matrix44<float>();
		printf("Ok\n");
		printf("testing matrix55...");
		test_matrix55<float>();
		printf("Ok\n");
	}

} // namespace test